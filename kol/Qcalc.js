// Generated by CoffeeScript 1.6.3
(function() {
  var Model, N_max, Q, STANDARD_REJECTION, analyze, bit_mon, bit_stream, cellar_mon, cellar_stream, dairy_stream, default_submodels, entry_mon, entry_stream, hee_mon, hee_stream, init, kitch_mon, kitch_stream, normalize, output, processStream, rat_stream, round, streams;

  cellar_mon = [1, 1];

  cellar_stream = [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1];

  dairy_stream = [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2];

  rat_stream = [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0];

  bit_mon = [1, 1, 1, 1, 1, 1, 1, 1];

  bit_stream = [0, 1, 0, 2, 0, 3, 4, 1, 3, 5, 0, 2, 6, 1, 2, 5, 3, 5, 4, 0, 5, 7, 6, 0, 7, 7, 5, 0, 6, 0, 4, 0, 4, 0, 1, 6, 4, 7, 0, 0, 1, 5, 6, 0, 6, 6, 3, 7, 0, 0, 7, 0, 3, 3, 5, 2, 6, 0, 1, 4, 0, 2, 0, 6, 2, 1, 3, 0, 4, 6, 0, 0, 1, 4, 5, 2, 1, 3, 0, 2, 6, 5, 0, 7, 0, 3, 6, 4, 0, 2, 5, 2, 7, 6, 1, 0, 3, 4, 0, 0, 0, 6, 0, 2, 2, 1, 4, 3, 1, 0, 5, 5, 2, 6, 0, 3, 0, 4, 0, 1, 0, 5, 6, 4, 2, 1, 7, 5, 7, 0, 3, 0, 2, 4, 5, 7, 1, 0, 3, 6, 4, 2, 4, 3, 7, 0, 6, 2];

  entry_mon = [1, 1, 1];

  entry_stream = [0, 0, 1, 2, 0, 0, 1, 0, 1, 0, 2, 0, 2, 1, 0, 0, 2, 0, 2, 0, 1, 0, 1, 2, 1, 0, 1, 0, 1, 2, 0, 2, 1, 1, 0, 0, 0, 2, 0, 0, 1, 2, 0, 0, 0, 1, 1, 0, 1, 0, 2, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 2, 2, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 1, 0, 0, 0, 2, 0, 1, 0, 0, 1, 2, 0, 2, 0, 0, 1, 2, 0, 2, 0, 0, 2, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 1, 0, 0, 1, 1, 2, 1, 0, 1, 1, 0, 0, 0, 2, 1, 0, 1, 0, 0, 2, 0, 1];

  kitch_mon = [1, 1, 1, 1, 1];

  kitch_stream = [0, 0, 1, 0, 2, 3, 4, 0, 3, 2, 1, 0, 4, 0, 3, 3, 1, 2, 0, 3, 0, 4, 0, 2, 0, 0, 0, 0, 1, 0, 0, 2, 1, 0, 0, 4, 3, 0, 3, 1, 0, 4, 4, 0, 3, 1, 3, 2, 0, 4, 0, 4, 3, 4, 2, 1, 0, 3, 0, 3, 0, 4, 3, 1, 3, 3, 0, 2, 0, 4, 1, 3, 0, 1, 0, 2, 0, 3, 4, 4, 4, 2, 0, 3, 0, 1, 4, 2, 1, 0, 3, 0, 2, 4, 3, 0, 0, 4, 2, 1, 0, 3, 2];

  hee_mon = [1, 1, 1];

  hee_stream = [0, 1, 0, 0, 0, 2, 0, 1, 2, 2, 0, 0, 0, 0, 1, 2, 0, 0, 2, 1, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 2, 1, 2, 1, 0, 1, 0, 0, 2, 2, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0, 2, 0, 0, 1, 0, 2, 0, 0, 2, 0, 1, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 1, 2, 1, 0, 0, 0, 2, 0, 1, 2, 2, 1, 2, 0, 0, 2, 1, 2, 1, 0, 0, 0, 1, 2, 0, 2, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 1, 1, 2, 0, 0, 0, 0, 2, 1, 0, 1, 0];

  streams = [
    {
      monsters: bit_mon,
      stream: bit_stream
    }, {
      monsters: cellar_mon,
      stream: cellar_stream
    }, {
      monsters: entry_mon,
      stream: entry_stream
    }, {
      monsters: hee_mon,
      stream: hee_stream
    }, {
      monsters: kitch_mon,
      stream: kitch_stream
    }
  ];

  default_submodels = {
    "ignore the queue": 0,
    "normal queue": STANDARD_REJECTION
  };

  N_max = 20;

  STANDARD_REJECTION = 3 / 4;

  round = function(x) {
    return Math.round(x * 100000) / 1000;
  };

  window.analyze = analyze = function() {
    var data, models, _i, _len;
    models = init();
    for (_i = 0, _len = streams.length; _i < _len; _i++) {
      data = streams[_i];
      processStream(data, models);
    }
    normalize(models);
    return output(models);
  };

  output = function(models) {
    var mod, out, report, report_out, _i, _j, _len, _len1;
    out = "N\t\t normal Q\t\t no rej";
    report = [];
    for (_i = 0, _len = models.length; _i < _len; _i++) {
      mod = models[_i];
      if (mod.confidence >= .001) {
        report.push(mod);
      }
    }
    report.sort(function(a, b) {
      return b.confidence - a.confidence;
    });
    report_out = "";
    for (_j = 0, _len1 = report.length; _j < _len1; _j++) {
      mod = report[_j];
      report_out += mod.report() + "\n";
    }
    console.log(report_out);
    return window.document.getElementById("output").value = report_out;
  };

  window.runit = function() {
    var data;
    data = document.getElementById("data").value;
    streams = JSON.parse(data);
    return analyze();
  };

  init = function() {
    var models, n, name, rejection, smv, submodels, _i;
    models = [];
    submodels = default_submodels;
    smv = document.getElementById("submodels").value;
    submodels = JSON.parse(smv);
    for (n = _i = 0; 0 <= N_max ? _i <= N_max : _i >= N_max; n = 0 <= N_max ? ++_i : --_i) {
      for (name in submodels) {
        rejection = submodels[name];
        models.push(new Model(n, rejection, "+" + n + " copies, " + name));
      }
    }
    return models;
  };

  normalize = function(models) {
    var max, mod, tot, _i, _j, _k, _len, _len1, _len2, _results;
    tot = 0;
    max = -Infinity;
    for (_i = 0, _len = models.length; _i < _len; _i++) {
      mod = models[_i];
      max = Math.max(mod.log_prob, max);
    }
    for (_j = 0, _len1 = models.length; _j < _len1; _j++) {
      mod = models[_j];
      tot += mod.confidence = Math.exp(mod.log_prob - max);
    }
    _results = [];
    for (_k = 0, _len2 = models.length; _k < _len2; _k++) {
      mod = models[_k];
      _results.push(mod.confidence /= tot);
    }
    return _results;
  };

  processStream = function(data, models) {
    var i, m, mod, monsters, queue, stream, _i, _j, _k, _len, _len1, _len2, _results;
    stream = data.stream;
    monsters = data.monsters;
    for (_i = 0, _len = models.length; _i < _len; _i++) {
      mod = models[_i];
      mod.setZone(monsters);
    }
    queue = new Q();
    _results = [];
    for (i = _j = 0, _len1 = stream.length; _j < _len1; i = ++_j) {
      m = stream[i];
      if (i >= 5) {
        for (_k = 0, _len2 = models.length; _k < _len2; _k++) {
          mod = models[_k];
          mod.processDataPoint(m, queue);
        }
      }
      _results.push(queue.add(m));
    }
    return _results;
  };

  Q = (function() {
    function Q() {
      this.queue = [];
    }

    Q.prototype.reset = function() {
      return this.queue = [];
    };

    Q.prototype.add = function(id) {
      this.queue.push(id);
      if (this.queue.length > 5) {
        return this.queue.shift();
      }
    };

    Q.prototype.check = function(id) {
      var monster, _i, _len, _ref;
      _ref = this.queue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        monster = _ref[_i];
        if (id === monster) {
          return true;
        }
      }
      return false;
    };

    return Q;

  })();

  Model = (function() {
    function Model(N, j_special, description) {
      this.N = N;
      this.rej = [];
      this.j_special = j_special;
      this.log_prob = 0;
      this.description = description;
    }

    Model.prototype.report = function() {
      return "" + (this.con()) + "% " + this.description;
    };

    Model.prototype.con = function() {
      return Math.round(this.confidence * 100000) / 1000;
    };

    Model.prototype.setZone = function(monsters) {
      var copies, e, i, _i, _j, _len, _len1, _results;
      this.monsters = monsters;
      this.rates = [];
      e = 0;
      for (_i = 0, _len = monsters.length; _i < _len; _i++) {
        copies = monsters[_i];
        e += copies;
      }
      _results = [];
      for (i = _j = 0, _len1 = monsters.length; _j < _len1; i = ++_j) {
        copies = monsters[i];
        if (i === 0) {
          _results.push(this.rates[i] = (copies + this.N) / (e + this.N));
        } else {
          _results.push(this.rates[i] = copies / (e + this.N));
        }
      }
      return _results;
    };

    Model.prototype.processDataPoint = function(i, queue) {
      return this.log_prob += Math.log(this.p(i, queue));
    };

    Model.prototype.p = function(i, queue) {
      var j, r, rej;
      r = this.rates[i];
      j = this.getJ(i, queue);
      rej = this.getRej(queue);
      return r * (1 - j) / (1 - rej);
    };

    Model.prototype.getJ = function(i, queue) {
      if (queue.check(i)) {
        if (i === 0) {
          return this.j_special;
        } else {
          return STANDARD_REJECTION;
        }
      } else {
        return 0;
      }
    };

    Model.prototype.getRej = function(queue) {
      var m, r, rej, _i, _len, _ref;
      rej = 0;
      _ref = this.rates;
      for (m = _i = 0, _len = _ref.length; _i < _len; m = ++_i) {
        r = _ref[m];
        rej += r * this.getJ(m, queue);
      }
      return rej;
    };

    return Model;

  })();

}).call(this);
