// Generated by CoffeeScript 1.4.0
(function() {
  var Apply, CombinationSum, Confidences, CreateArray, ExpArray, FindLnProb, FindLnProbArray, Get, Log, Progress, RATESET, Run, Set, Stop, certainty, max_rates;

  self.console = {
    log: function(msg) {
      return msg;
    }
  };

  RATESET = [];

  max_rates = [];

  certainty = 0;

  Confidences = [];

  self.onmessage = function(event) {
    var msg;
    msg = event.data;
    switch (msg.type) {
      case 'RUN':
        return Run(msg.dataset, msg.range);
      case 'STOP':
        return Stop(msg);
    }
  };

  Stop = function(msg) {
    return self.close();
  };

  Run = function(dataset, range) {
    var ArrayOfProbs, msg, n, point, _i, _j, _k, _len, _results, _results1;
    if (range == null) {
      range = 'FULL';
    }
    switch (range) {
      case 'FULL':
        RATESET = (function() {
          _results = [];
          for (_i = 1; _i <= 100; _i++){ _results.push(_i); }
          return _results;
        }).apply(this);
        break;
      case 'SPARSE':
        RATESET = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100];
        break;
      case 'FULL-NEG':
        RATESET = (function() {
          _results1 = [];
          for (_j = -100; _j <= 100; _j++){ _results1.push(_j); }
          return _results1;
        }).apply(this);
        break;
      case 'SUPER LOW':
        RATESET = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3];
        break;
      default:
        RATESET = JSON.parse(range);
    }
    ArrayOfProbs = CreateArray(dataset[0].counts.length - 2);
    for (n = _k = 0, _len = dataset.length; _k < _len; n = ++_k) {
      point = dataset[n];
      Progress(Math.floor((n + 1) / (dataset.length + 3) * 100));
      FindLnProbArray(ArrayOfProbs, point.counts, point.boost, point.flat_boost);
    }
    Progress(Math.floor((dataset.length + 2) / (dataset.length + 2) * 100));
    ExpArray(ArrayOfProbs);
    Progress(100);
    msg = {
      'type': 'RESULT',
      'results': Confidences
    };
    postMessage(msg);
    ArrayOfProbs = [];
    Confidences = [];
    dataset = [];
    max_rates = [];
  };

  ExpArray = function(ArrayOfProbs) {
    var GetExp, GetMax, GetTopResults, Norm, Round, max, sum;
    max = -Infinity;
    GetMax = function(a, i, r) {
      if (a[i] > max) {
        max = a[i];
        return max_rates = r;
      }
    };
    Apply(ArrayOfProbs, GetMax);
    sum = 0;
    GetExp = function(a, i) {
      a[i] = Math.pow(Math.E, a[i] - max);
      if (!isNaN(a[i])) {
        return sum += a[i];
      }
    };
    Apply(ArrayOfProbs, GetExp);
    Norm = function(a, i) {
      return a[i] = a[i] / sum;
    };
    Apply(ArrayOfProbs, Norm);
    certainty = Get(ArrayOfProbs, max_rates);
    Round = function(x) {
      return Math.floor(x * 10000) / 100;
    };
    GetTopResults = function(a, i, r) {
      if (a[i] * 10 > certainty || a[i] > 0.01) {
        return Confidences.push({
          rates: r,
          belief: Round(a[i])
        });
      }
    };
    Apply(ArrayOfProbs, GetTopResults);
  };

  FindLnProbArray = function(ArrayOfProbs, counts, boost, flat_boost) {
    var FLP;
    if (boost == null) {
      boost = 0;
    }
    if (flat_boost == null) {
      flat_boost = 0;
    }
    FLP = function(a, i, rates) {
      return a[i] += FindLnProb(counts, boost, rates, flat_boost);
    };
    Apply(ArrayOfProbs, FLP);
    return ArrayOfProbs;
  };

  CombinationSum = function(r, n) {
    var chosen_rate, i, rate, result, s, _i, _j, _len, _len1;
    if (n > r.length) {
      return 0;
    }
    if (n === 0) {
      result = 1;
      for (_i = 0, _len = r.length; _i < _len; _i++) {
        rate = r[_i];
        result *= 1 - rate;
      }
      return result;
    }
    result = 0;
    for (i = _j = 0, _len1 = r.length; _j < _len1; i = ++_j) {
      chosen_rate = r[i];
      s = r.slice(0);
      s.splice(i, 1);
      result += chosen_rate * CombinationSum(s, n - 1);
    }
    return result / n;
  };

  FindLnProb = function(counts, boost, rates, flat_boost) {
    var LnChance, c, count, i, mandate, ob_rates, rate, result, _i, _j, _len, _len1;
    if (rates == null) {
      rates = 0;
    }
    if (flat_boost == null) {
      flat_boost = 0;
    }
    ob_rates = new Array();
    mandate = 0;
    for (i = _i = 0, _len = rates.length; _i < _len; i = ++_i) {
      rate = rates[i];
      ob_rates[i] = rate / 100 * (1 + boost / 100) + flat_boost / 100;
      if (ob_rates[i] > 1) {
        ob_rates[i] = 1;
        mandate++;
      }
      if (ob_rates[i] < 0) {
        ob_rates[i] = 0;
      }
    }
    LnChance = 0;
    for (c = _j = 0, _len1 = counts.length; _j < _len1; c = ++_j) {
      count = counts[c];
      if (mandate > c) {
        if (count !== 0) {
          return NaN;
        }
      } else {
        if (count === 0) {
          result = 1;
        } else {
          result = CombinationSum(ob_rates, c);
        }
        LnChance += count * Math.log(result);
      }
    }
    return LnChance;
  };

  Apply = function(a, action, rates) {
    var i, s, _i, _len;
    if (rates == null) {
      rates = [];
    }
    for (_i = 0, _len = RATESET.length; _i < _len; _i++) {
      i = RATESET[_i];
      if (rates.length > 0) {
        if (rates[rates.length - 1] < i) {
          return;
        }
      }
      s = rates.slice(0);
      s.push(i);
      if (a[i].length > 1) {
        Apply(a[i], action, s);
      } else {
        action(a, i, s);
      }
    }
  };

  CreateArray = function(m) {
    var i, root, _i, _len;
    root = new Array();
    for (_i = 0, _len = RATESET.length; _i < _len; _i++) {
      i = RATESET[_i];
      if (m > 0) {
        root[i] = CreateArray(m - 1);
      } else {
        root[i] = 0;
      }
    }
    return root;
  };

  /*
  Get and Set both use a kind of 'recursive for loop' construct to do their job.
  Maybe there's a more idiomatic way of doing this?
  
  The reason it requires the loop is because we don't know the dimension of the data structure.
  */


  Get = function(a, indices) {
    var index, _i, _len;
    for (_i = 0, _len = indices.length; _i < _len; _i++) {
      index = indices[_i];
      a = a[index];
    }
    return a;
  };

  Set = function(a, indices, value) {
    var index, n, _i, _len, _results;
    _results = [];
    for (n = _i = 0, _len = indices.length; _i < _len; n = ++_i) {
      index = indices[n];
      if (n < indices.length - 1) {
        _results.push(a = a[index]);
      } else {
        _results.push(a[index] = value);
      }
    }
    return _results;
  };

  Progress = function(percent, message) {
    var msg;
    if (message == null) {
      message = "";
    }
    msg = {
      'type': 'PROGRESS',
      'percent': percent
    };
    return postMessage(msg);
  };

  Log = function(text) {
    var msg;
    msg = {
      'type': 'LOG',
      'text': text
    };
    return postMessage(msg);
  };

}).call(this);
